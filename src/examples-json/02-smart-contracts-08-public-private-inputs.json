{"type":"playground","base":"smart-contract","files":{"src":{"directory":{"main*ts":{"file":{"contents":"import {\n  SmartContract,\n  PrivateKey,\n  Field,\n  method,\n  AccountUpdate,\n  Mina,\n  state,\n  State,\n  Provable,\n  Poseidon,\n} from \"o1js\";\n\nclass HelloWorld extends SmartContract {\n  @state(Field) x = State<Field>();\n\n  init() {\n    super.init();\n    this.x.set(Poseidon.hash([Field(1)]));\n  }\n\n  @method incrementSecret(secret: Field) {\n    const x = this.x.get();\n    this.x.assertEquals(x);\n\n    Poseidon.hash([secret]).assertEquals(x);\n    this.x.set(Poseidon.hash([secret.add(1)]));\n  }\n}\n\nconst useProof = false;\nconst Local = Mina.LocalBlockchain({ proofsEnabled: useProof });\nMina.setActiveInstance(Local);\nconst { privateKey: deployerKey, publicKey: deployerAccount } =\n  Local.testAccounts[0];\nconst { privateKey: senderKey, publicKey: senderAccount } =\n  Local.testAccounts[1];\n\nconst zkAppPrivateKey = PrivateKey.random();\nconst zkAppAddress = zkAppPrivateKey.toPublicKey();\nconst zkAppInstance = new HelloWorld(zkAppAddress);\nconst deployTxn = await Mina.transaction(deployerAccount, () => {\n  AccountUpdate.fundNewAccount(deployerAccount);\n  zkAppInstance.deploy();\n});\nawait deployTxn.sign([deployerKey, zkAppPrivateKey]).send();\n\nconst txn1 = await Mina.transaction(senderAccount, () => {\n  zkAppInstance.incrementSecret(Field(1));\n});\nawait txn1.prove();\nconst transaction = await txn1.sign([senderKey]).send();\nProvable.log(transaction);\n\nconst txn2 = await Mina.transaction(senderAccount, () => {\n  zkAppInstance.incrementSecret(Field(2));\n});\nawait txn2.prove();\nconst transaction2 = await txn2.sign([senderKey]).send();\nProvable.log(transaction2);\n"}}}}},"filesArray":["src/main.ts"],"highlightedItem":{"highlightedName":"main*ts","highlightedCode":"import {\n  SmartContract,\n  PrivateKey,\n  Field,\n  method,\n  AccountUpdate,\n  Mina,\n  state,\n  State,\n  Provable,\n  Poseidon,\n} from \"o1js\";\n\nclass HelloWorld extends SmartContract {\n  @state(Field) x = State<Field>();\n\n  init() {\n    super.init();\n    this.x.set(Poseidon.hash([Field(1)]));\n  }\n\n  @method incrementSecret(secret: Field) {\n    const x = this.x.get();\n    this.x.assertEquals(x);\n\n    Poseidon.hash([secret]).assertEquals(x);\n    this.x.set(Poseidon.hash([secret.add(1)]));\n  }\n}\n\nconst useProof = false;\nconst Local = Mina.LocalBlockchain({ proofsEnabled: useProof });\nMina.setActiveInstance(Local);\nconst { privateKey: deployerKey, publicKey: deployerAccount } =\n  Local.testAccounts[0];\nconst { privateKey: senderKey, publicKey: senderAccount } =\n  Local.testAccounts[1];\n\nconst zkAppPrivateKey = PrivateKey.random();\nconst zkAppAddress = zkAppPrivateKey.toPublicKey();\nconst zkAppInstance = new HelloWorld(zkAppAddress);\nconst deployTxn = await Mina.transaction(deployerAccount, () => {\n  AccountUpdate.fundNewAccount(deployerAccount);\n  zkAppInstance.deploy();\n});\nawait deployTxn.sign([deployerKey, zkAppPrivateKey]).send();\n\nconst txn1 = await Mina.transaction(senderAccount, () => {\n  zkAppInstance.incrementSecret(Field(1));\n});\nawait txn1.prove();\nconst transaction = await txn1.sign([senderKey]).send();\nProvable.log(transaction);\n\nconst txn2 = await Mina.transaction(senderAccount, () => {\n  zkAppInstance.incrementSecret(Field(2));\n});\nawait txn2.prove();\nconst transaction2 = await txn2.sign([senderKey]).send();\nProvable.log(transaction2);\n"},"focusedFiles":{"main*ts":{"file":{"contents":"import {\n  SmartContract,\n  PrivateKey,\n  Field,\n  method,\n  AccountUpdate,\n  Mina,\n  state,\n  State,\n  Provable,\n  Poseidon,\n} from \"o1js\";\n\nclass HelloWorld extends SmartContract {\n  @state(Field) x = State<Field>();\n\n  init() {\n    super.init();\n    this.x.set(Poseidon.hash([Field(1)]));\n  }\n\n  @method incrementSecret(secret: Field) {\n    const x = this.x.get();\n    this.x.assertEquals(x);\n\n    Poseidon.hash([secret]).assertEquals(x);\n    this.x.set(Poseidon.hash([secret.add(1)]));\n  }\n}\n\nconst useProof = false;\nconst Local = Mina.LocalBlockchain({ proofsEnabled: useProof });\nMina.setActiveInstance(Local);\nconst { privateKey: deployerKey, publicKey: deployerAccount } =\n  Local.testAccounts[0];\nconst { privateKey: senderKey, publicKey: senderAccount } =\n  Local.testAccounts[1];\n\nconst zkAppPrivateKey = PrivateKey.random();\nconst zkAppAddress = zkAppPrivateKey.toPublicKey();\nconst zkAppInstance = new HelloWorld(zkAppAddress);\nconst deployTxn = await Mina.transaction(deployerAccount, () => {\n  AccountUpdate.fundNewAccount(deployerAccount);\n  zkAppInstance.deploy();\n});\nawait deployTxn.sign([deployerKey, zkAppPrivateKey]).send();\n\nconst txn1 = await Mina.transaction(senderAccount, () => {\n  zkAppInstance.incrementSecret(Field(1));\n});\nawait txn1.prove();\nconst transaction = await txn1.sign([senderKey]).send();\nProvable.log(transaction);\n\nconst txn2 = await Mina.transaction(senderAccount, () => {\n  zkAppInstance.incrementSecret(Field(2));\n});\nawait txn2.prove();\nconst transaction2 = await txn2.sign([senderKey]).send();\nProvable.log(transaction2);\n"}}}}