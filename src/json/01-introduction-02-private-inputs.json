{"name":"Private Inputs","test":"Private.test.ts","tutorial":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsxDEV: _jsxDEV} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nconst chCodeConfig = {\n  \"staticMediaQuery\": \"not screen, (max-width: 768px)\",\n  \"autoImport\": false,\n  \"showCopyButton\": true,\n  \"theme\": {},\n  \"skipLanguages\": [],\n  \"filepath\": undefined\n};\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components), {CH} = _components;\n  if (!CH) _missingMdxReference(\"CH\", false, \"7:1-11:4\");\n  if (!CH.Code) _missingMdxReference(\"CH.Code\", true, \"7:1-11:4\");\n  return _jsxDEV(_Fragment, {\n    children: [_jsxDEV(_components.h1, {\n      children: \"Private Inputs\"\n    }, undefined, false, {\n      fileName: \"<source.js>\",\n      lineNumber: 1,\n      columnNumber: 1\n    }, this), \"\\n\", _jsxDEV(_components.p, {\n      children: \"In this tutorial, we will discuss private inputs and hash functions. With a zkApp, a user's local device generates one or more zero knowledge proofs, which are then verified by the Mina network. Each method in a SnarkyJS smart contract corresponds to constructing a proof.\"\n    }, undefined, false, {\n      fileName: \"<source.js>\",\n      lineNumber: 2,\n      columnNumber: 1\n    }, this), \"\\n\", _jsxDEV(_components.p, {\n      children: \"As such, all inputs to a smart contract are private by default, and never seen by the blockchain, unless the developer chooses to store those values as on-chain state in the zkApp account. We will build a smart contract with a piece of private state, that can be modified if a user knows the private state.\"\n    }, undefined, false, {\n      fileName: \"<source.js>\",\n      lineNumber: 4,\n      columnNumber: 1\n    }, this), \"\\n\", _jsxDEV(_components.p, {\n      children: [\"Now, we will add an \", _jsxDEV(_components.strong, {\n        children: \"initState()\"\n      }, undefined, false, {\n        fileName: \"<source.js>\",\n        lineNumber: 6,\n        columnNumber: 21\n      }, this), \" method. This is intended to run once to set up the initial state on the zkApp account :\"]\n    }, undefined, true, {\n      fileName: \"<source.js>\",\n      lineNumber: 6,\n      columnNumber: 1\n    }, this), \"\\n\", _jsxDEV(CH.Code, {\n      codeConfig: chCodeConfig,\n      northPanel: {\n        \"tabs\": [\"\"],\n        \"active\": \"\",\n        \"heightRatio\": 1\n      },\n      files: [{\n        \"name\": \"\",\n        \"focus\": \"\",\n        \"code\": {\n          \"lines\": [{\n            \"tokens\": [{\n              \"content\": \"@method initState(salt: Field, firstSecret: Field) {\",\n              \"props\": {\n                \"style\": {\n                  \"color\": \"#BBBBBB\"\n                }\n              }\n            }]\n          }, {\n            \"tokens\": [{\n              \"content\": \"  this.x.set(Poseidon.hash([ salt, firstSecret ]));\",\n              \"props\": {\n                \"style\": {\n                  \"color\": \"#BBBBBB\"\n                }\n              }\n            }]\n          }, {\n            \"tokens\": [{\n              \"content\": \"}\",\n              \"props\": {\n                \"style\": {\n                  \"color\": \"#BBBBBB\"\n                }\n              }\n            }]\n          }],\n          \"lang\": \"ts\"\n        },\n        \"annotations\": []\n      }]\n    }, undefined, false, {\n      fileName: \"<source.js>\",\n      lineNumber: 7,\n      columnNumber: 1\n    }, this), \"\\n\", _jsxDEV(_components.p, {\n      children: [\"Our \", _jsxDEV(_components.strong, {\n        children: \"initState()\"\n      }, undefined, false, {\n        fileName: \"<source.js>\",\n        lineNumber: 12,\n        columnNumber: 5\n      }, this), \" method accepts our secret, and a value called a \\\"salt\\\", which we will discuss later. Note that these inputs to our \", _jsxDEV(_components.strong, {\n        children: \"initState()\"\n      }, undefined, false, {\n        fileName: \"<source.js>\",\n        lineNumber: 12,\n        columnNumber: 136\n      }, this), \" method are private to whomever initializes the contract. Nobody looking at the zkApp account on the chain can see or know what values \", _jsxDEV(_components.strong, {\n        children: \"firstSecret\"\n      }, undefined, false, {\n        fileName: \"<source.js>\",\n        lineNumber: 12,\n        columnNumber: 286\n      }, this), \" or \", _jsxDEV(_components.strong, {\n        children: \"salt\"\n      }, undefined, false, {\n        fileName: \"<source.js>\",\n        lineNumber: 12,\n        columnNumber: 305\n      }, this), \" actually are.\"]\n    }, undefined, true, {\n      fileName: \"<source.js>\",\n      lineNumber: 12,\n      columnNumber: 1\n    }, this), \"\\n\", _jsxDEV(_components.h1, {\n      children: \"Update with Poseidon\"\n    }, undefined, false, {\n      fileName: \"<source.js>\",\n      lineNumber: 14,\n      columnNumber: 1\n    }, this), \"\\n\", _jsxDEV(_components.p, {\n      children: \"Next we will add a method to update our state:\"\n    }, undefined, false, {\n      fileName: \"<source.js>\",\n      lineNumber: 16,\n      columnNumber: 1\n    }, this), \"\\n\", _jsxDEV(CH.Code, {\n      codeConfig: chCodeConfig,\n      northPanel: {\n        \"tabs\": [\"\"],\n        \"active\": \"\",\n        \"heightRatio\": 1\n      },\n      files: [{\n        \"name\": \"\",\n        \"focus\": \"\",\n        \"code\": {\n          \"lines\": [{\n            \"tokens\": [{\n              \"content\": \"@method incrementSecret(salt: Field, secret: Field) {\",\n              \"props\": {\n                \"style\": {\n                  \"color\": \"#BBBBBB\"\n                }\n              }\n            }]\n          }, {\n            \"tokens\": [{\n              \"content\": \"  const x = this.x.get();\",\n              \"props\": {\n                \"style\": {\n                  \"color\": \"#BBBBBB\"\n                }\n              }\n            }]\n          }, {\n            \"tokens\": [{\n              \"content\": \"  this.x.assertEquals(x);\",\n              \"props\": {\n                \"style\": {\n                  \"color\": \"#BBBBBB\"\n                }\n              }\n            }]\n          }, {\n            \"tokens\": [{\n              \"content\": \"\",\n              \"props\": {\n                \"style\": {\n                  \"color\": \"#BBBBBB\"\n                }\n              }\n            }]\n          }, {\n            \"tokens\": [{\n              \"content\": \"  Poseidon.hash([salt, secret]).assertEquals(x);\",\n              \"props\": {\n                \"style\": {\n                  \"color\": \"#BBBBBB\"\n                }\n              }\n            }]\n          }, {\n            \"tokens\": [{\n              \"content\": \"  this.x.set(Poseidon.hash([salt, secret.add(1)]));\",\n              \"props\": {\n                \"style\": {\n                  \"color\": \"#BBBBBB\"\n                }\n              }\n            }]\n          }, {\n            \"tokens\": [{\n              \"content\": \"}\",\n              \"props\": {\n                \"style\": {\n                  \"color\": \"#BBBBBB\"\n                }\n              }\n            }]\n          }],\n          \"lang\": \"ts\"\n        },\n        \"annotations\": []\n      }]\n    }, undefined, false, {\n      fileName: \"<source.js>\",\n      lineNumber: 17,\n      columnNumber: 1\n    }, this), \"\\n\", _jsxDEV(_components.p, {\n      children: \"Mina uses the Poseidon hash function, which has been optimized for fast performance inside zero knowledge proof systems. The Poseidon hash function takes in an array of Fields, and returns a single Field as output.\"\n    }, undefined, false, {\n      fileName: \"<source.js>\",\n      lineNumber: 26,\n      columnNumber: 1\n    }, this), \"\\n\", _jsxDEV(_components.p, {\n      children: \"In this smart contract, we use both a secret number, and a second Field, known as a \\\"salt\\\".\"\n    }, undefined, false, {\n      fileName: \"<source.js>\",\n      lineNumber: 28,\n      columnNumber: 1\n    }, this), \"\\n\", _jsxDEV(_components.p, {\n      children: [\"In the \", _jsxDEV(_components.strong, {\n        children: \"incrementSecret()\"\n      }, undefined, false, {\n        fileName: \"<source.js>\",\n        lineNumber: 30,\n        columnNumber: 8\n      }, this), \" method, we check that the hash of the salt and our secret is equal to the current state \", _jsxDEV(_components.strong, {\n        children: \"x\"\n      }, undefined, false, {\n        fileName: \"<source.js>\",\n        lineNumber: 30,\n        columnNumber: 118\n      }, this), \". If this is the case, we add \", _jsxDEV(_components.strong, {\n        children: \"1\"\n      }, undefined, false, {\n        fileName: \"<source.js>\",\n        lineNumber: 30,\n        columnNumber: 153\n      }, this), \" to the secret and set \", _jsxDEV(_components.strong, {\n        children: \"x\"\n      }, undefined, false, {\n        fileName: \"<source.js>\",\n        lineNumber: 30,\n        columnNumber: 181\n      }, this), \" to the hash of the salt and this new secret. SnarkyJS creates a proof of this fact, and a JSON description of the state updates to be made on the zkApp account, such as to store our new hash value, which together form a transaction that can be sent to the Mina network to update the zkApp account.\"]\n    }, undefined, true, {\n      fileName: \"<source.js>\",\n      lineNumber: 30,\n      columnNumber: 1\n    }, this), \"\\n\", _jsxDEV(_components.p, {\n      children: [\"Because zkApp smart contracts are run off chain, our salt and secret remain private and are never transmitted anywhere. Only the result, updating \", _jsxDEV(_components.strong, {\n        children: \"x\"\n      }, undefined, false, {\n        fileName: \"<source.js>\",\n        lineNumber: 32,\n        columnNumber: 147\n      }, this), \" on-chain state to \", _jsxDEV(_components.strong, {\n        children: \"hash([ salt, secret + 1])\"\n      }, undefined, false, {\n        fileName: \"<source.js>\",\n        lineNumber: 32,\n        columnNumber: 171\n      }, this), \" is revealed. Because the salt and secret can't be deduced from their hash, they remain private.\"]\n    }, undefined, true, {\n      fileName: \"<source.js>\",\n      lineNumber: 32,\n      columnNumber: 1\n    }, this)]\n  }, undefined, true, {\n    fileName: \"<source.js>\",\n    lineNumber: 1,\n    columnNumber: 1\n  }, this);\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsxDEV(MDXLayout, Object.assign({}, props, {\n    children: _jsxDEV(_createMdxContent, props, undefined, false, {\n      fileName: \"<source.js>\"\n    }, this)\n  }), undefined, false, {\n    fileName: \"<source.js>\"\n  }, this) : _createMdxContent(props);\n}\nreturn {\n  chCodeConfig,\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component, place) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\" + (place ? \"\\nIt’s referenced in your code at `\" + place + \"`\" : \"\"));\n}\n","frontmatter":{},"scope":{}},"files":{},"highlight":"Private.ts","focusedFiles":{"Private*ts":{"file":{"contents":"import { Field, SmartContract, state, State, method, Poseidon } from \"snarkyjs\";\n\nexport class Private extends SmartContract {\n  @state(Field) x = State<Field>();\n}\n"}}},"testFiles":{"Private*test*ts":{"file":{"contents":"import { Private } from \"../src/Private\";\nimport {\n  Field,\n  Mina,\n  PrivateKey,\n  PublicKey,\n  AccountUpdate,\n  Poseidon,\n} from \"snarkyjs\";\n\nlet proofsEnabled = false;\n\ndescribe(\"Private\", () => {\n  let deployerAccount: PublicKey,\n    deployerKey: PrivateKey,\n    senderAccount: PublicKey,\n    senderKey: PrivateKey,\n    zkAppAddress: PublicKey,\n    zkAppPrivateKey: PrivateKey,\n    zkApp: Private;\n\n  beforeAll(async () => {\n    if (proofsEnabled) await Private.compile();\n  });\n\n  beforeEach(() => {\n    const Local = Mina.LocalBlockchain({ proofsEnabled });\n    Mina.setActiveInstance(Local);\n    ({ privateKey: deployerKey, publicKey: deployerAccount } =\n      Local.testAccounts[0]);\n    ({ privateKey: senderKey, publicKey: senderAccount } =\n      Local.testAccounts[1]);\n    zkAppPrivateKey = PrivateKey.random();\n    zkAppAddress = zkAppPrivateKey.toPublicKey();\n    zkApp = new Private(zkAppAddress);\n  });\n\n  async function localDeploy() {\n    const txn = await Mina.transaction(deployerAccount, () => {\n      AccountUpdate.fundNewAccount(deployerAccount);\n      zkApp.deploy();\n      zkApp.initState(Field(100), Field(150));\n    });\n    await txn.prove();\n    await txn.sign([deployerKey, zkAppPrivateKey]).send();\n  }\n\n  it(\"generates and deploys the `Private` smart contract and checks the Poseidon hash\", async () => {\n    await localDeploy();\n    const x = zkApp.x.get();\n    expect(x).toEqual(Poseidon.hash([Field(100), Field(150)]));\n  });\n\n  it(\"correctly increments a secret on the `Private` smart contract using a Poseidon hash\", async () => {\n    await localDeploy();\n\n    // update transaction\n    const txn = await Mina.transaction(senderAccount, () => {\n      zkApp.incrementSecret(Field(100), Field(150));\n    });\n    await txn.prove();\n    await txn.sign([senderKey]).send();\n\n    const x = zkApp.x.get();\n    expect(x).toEqual(Poseidon.hash([Field(100), Field(151)]));\n  });\n});\n"}}}}