# Smart Contract Basics
This tutorial helps you get started with SnarkyJS, zkApps, and programming with zero-knowledge proofs.

In this step-by-step tutorial, you learn to code a zkApp from start to finish.

You will:

* Write a basic smart contract that stores a number as on-chain state.
* The contract logic allows this number to be replaced only by its square; for example, 3 -> 9 -> 81, and so on.
* Create a project using the Mina zkApp CLI
* Write your smart contract code
* Use a local Mina blockchain to interact with your smart contract.

Later tutorials introduce more concepts and patterns.

# Write the zkApp Smart Contract

This part of the tutorial walks you through the Square smart contract code already completed in the Square.ts file.

The ***import*** statement brings in other packages and dependencies to use in your smart contract.

All functions used inside a smart contract must operate on SnarkyJS compatible data types: ***Field*** types and other types built on top of ***Field*** types.

```ts
import {
  Field,
  SmartContract,
  state,
  State,
  method,
} from 'snarkyjs';
```

These items are:

* ***Field***: The native number type in SnarkyJS. You can think of Field elements as unsigned integers. Field elements are the most basic type in SnarkyJS. All other SnarkyJS-compatible types are built on top of Field elements.
* ***SmartContract***: The class that creates zkApp smart contracts.
* ***state***: A convenience decorator used in zkApp smart contracts to create references to state stored on-chain in a zkApp account.
* ***State***: A class used in zkApp smart contracts to create state stored on-chain in a zkApp account.
* ***method***: A convenience decorator used in zkApp smart contracts to create smart contract methods like functions. Methods that use this decorator are the end user's entry points to interacting with a smart contract.

# Smart contract class
Now, review the smart contract in the ***Square.ts*** file.

The smart contract called ***Square*** has one element of on-chain state named ***num*** of type ***Field*** as defined by following code:

```ts
export class Square extends SmartContract {
  @state(Field) num = State<Field>();
}
```
zkApps can have up to eight fields of on-chain state. Each field stores up to 32 bytes (technically, 31.875 bytes or 255 bits) of arbitrary data. A later tutorial covers options for off-chain state.

Now, this code adds the ***init*** method to set up the initial state of the smart contract on deployment:

```ts
export class Square extends SmartContract {
  @state(Field) num = State<Field>();
  init() {
    super.init();
    this.num.set(Field(3));
  }
}
```

Since you're extending ***SmartContract*** that has its own initialization to perform, calling ***super.init()*** invokes this function on the base class.

Then, ***this.num.set(Field(3))*** initializes the on-chain state num to a value of 3.

You can optionally specify permissions. See setPermissions [setPermissions](https://docs.minaprotocol.com/zkapps/snarkyjs-reference/classes/SmartContract#setpermissions "setPermissions") in the SnarkyJS Reference documentation.

Finally, this code adds the ***update()*** function:

```ts
    this.num.set(Field(3));
  }
  @method update(square: Field) {
    const currentState = this.num.get();
    this.num.assertEquals(currentState);
    square.assertEquals(currentState.mul(currentState));
    this.num.set(square);
  }
}
```

The function name ***update*** is arbitrary, but it makes sense for this example. Notice how the ***@method*** decorator is used because it is intended to be invoked by end users by using a zkApp UI, or as in this case, the ***main.ts*** script.

This method contains the logic by which end users are allowed to update the zkApp's account state on chain.

A zkApp account is an account is on the Mina blockchain where a zkApp smart contract is deployed. A zkApp account has a verification key associated with it.

In this example, the code specifies:
* If the user provides a number (for example, 9) to the ***update()*** method that is the square of the existing on-chain state referred to as ***num*** (for example, 3), then update the ***num*** value that is stored on-chain to the provided value (in this case, 9).
* If the user provides a number that does not meet these conditions, they are unable to generate a proof or update the on-chain state.

These update conditions are accomplished by using assertions within the method. When a user invokes a method on a smart contract, all assertions must be true to generate the zero-knowledge proof from that smart contract. The Mina network accepts the transaction and updates the on-chain state only if the attached proof is valid. This assertion is how you can achieve predictable behavior in an off-chain execution model.

Notice that ***get()*** and ***set()*** methods are used for retrieving and setting on-chain state.

A smart contract retrieves the on-chain account state when it is first invoked if at least one ***get()*** exists within it.

Similarly, using ***set()*** changes the transaction to indicate that changes to this particular on-chain state are updated only when the transaction is received by the Mina network if it contains a valid authorization (usually, a valid authorization is a proof).

The logic also uses the ***.mul()*** method for multiplication of the values stored in Field types. You can view all available methods in the [SnarkyJS Reference](https://docs.minaprotocol.com/zkapps/snarkyjs-reference "SnarkyJS Reference") documentation.

You remember that functions in your smart contract must operate on SnarkyJS compatible data types: ***Field*** types and other types built on top of ***Field*** types. Because a smart contract is really a zero-knowledge circuit, functions from random NPM packages work inside a smart contract only if the functions the contract provides operate on SnarkyJS-compatible data types.

Importantly, data passed as an input to a smart contract method in SnarkyJS is private and never seen by the network.

You can also store data publicly on-chain when needed, like ***num*** in this example. A later tutorial covers an example that leverages privacy.

Congratulations, you have reviewed the complete smart contract code.

